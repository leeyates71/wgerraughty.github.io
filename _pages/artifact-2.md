---
permalink: /projects/artifact-2/
title: "Data Structures and Algorithms"
---

## Project Link
[Artifact 2 Project](https://github.com/wgerraughty/wgerraughty.github.io/tree/master/_projects/mergesort){:target="_blank" .btn .btn--primary}

## Narrative
The second artifact, representing the Algorithms and Data Structures portion of the ePortfolio is a Merge Sort algorithm written in Java. This project was first developed for UMass Amherst’s CS187 course, Data Structures and Algorithms. The algorithm takes an unbounded queue and recursively divides the queue into units of 1, then merges them together and sorts the input queues during the merge. The unbounded queue was originally defined by the UnboundedQueueInterface specification written by the professors, and these specifications dictated many of the design choices for the algorithm.

I had chosen this artifact for the portfolio because I believe it was the best representation of my work with algorithms. Merge Sorting, on top of being useful as a sorting function, is both not too complicated to convey the process as well as not so easy to implement that it becomes meaningless. The most important part of this project was being able to work within the guidelines set by the specifications in the interface. There are many ways to implement merge sorting, but the specifications in the interface required us to think about potential trade-offs of different methods and program logic. With the enhancement, the algorithm was optimized to take into account “runs” of data to reduce the number of calls necessary in a best-case scenario and the time taken when merging. This can be seen in the test suite by comparing the “testMergeSortRandom” and “testMergeSortLarge” times, as sorting the random queue loses out by about 25 milliseconds on average for 10,000 elements.

This enhancement was planned to line up with course outcome CS-499-03: solving problems using algorithmic principles and computer science practices while managing trade-offs in design choices. While the previous artifact also touched on sections of this course outcome, I feel that this project solidifies my work in this area. This project also features numerous unit tests to verify the structure and logic of the algorithm, which works well for demonstrating a security-based mindset as well. Anticipating bad data and ensuring that the program acts as expected when it encounters this data is an important part of the design process, and unit testing is a great method of showing this in practice.

As I was working on this enhancement, I found it to be both easier than expected and more complicated at the same time. During the code review and planning, I had an idea of how I wanted to implement the changes to meet the enhancement goals that ended up being entirely unnecessary. In my initial thoughts, I had planned on adding fields to the queue object that would act as a check for if the queue is already sorted, but before I even began I had been reminded through the documentation in the project that the merge algorithm was already made to only take sorted queues as inputs. This meant all I had to do was check both the head and tail of one queue against the head of the other, and that would determine if the entirety of one queue could be merged first. To merge an entire queue required overloading the enqueue method and an additional helper method to take an input queue, copy it, and then enqueue every element. This method does not mutate the input queue to meet with the specifications, so another method had to be added to forcefully empty out the input queue. Lastly, I found I had to implement the ‘iterable’ interface in order to use for-each loops and make future test cases easier.
