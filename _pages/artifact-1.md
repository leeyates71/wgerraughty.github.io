---
permalink: /projects/artifact-1/
title: "Software Design and Engineering"
---

## Project Link
[Artifact 1 Project](https://github.com/wgerraughty/wgerraughty.github.io/tree/master/_projects/markov-chain){:target="_blank" .btn .btn--primary}

## Narrative

This first artifact, representing the Software Design and Engineering area of the ePortfolio, is a Markov Chain generator written in Python. This project was first developed for UMass Amherst’s CS220 course, Programming Methodology. Using text sources (like books) as input, the generator maintains a list of every possible ‘state’ of words as well as all possible future steps from the current state. This generator builds a chain of these states, with a two word ‘prefix’ tuple representing the current state and an immutable dictionary of suffixes as a value. This suffix dictionary has every potential next step as a key and the number of times it appears as a value to weight the probability of each next state. Using this, it randomly selects words from each state’s possible future to form new sentences.

I selected this project for the ePortfolio because it was one of the most complex projects that I have done for a course so far. The goal behind the project was to develop a provably safe program that produces no side effects. This focus on having no side effects leads to a variety of development choices that may seem overly complicated, such as using an immutable dictionary over a normal dictionary and mainly using higher-order functions and recursion for the program’s logic. Developing a provably safe program in this way required a lot of planning in the beginning, as it is heavy on recursion, to understand what direction to take with it. The primary goal of the enhancement was to allow for multiple inputs to combine several sources into a single chain, but during the code review it became immediately apparent that the code also needed cleaning and that there was a severe lack of documentation.
 
When selecting this project, I had planned on it being used mainly for meeting course outcome CS-499-04, which centers on being able to deliver functional software that meets project goals. With this enhancement, I believe that in addition to meeting course outcome CS-499-04 as planned this project goes beyond that and includes aspects from the other development focused outcomes CS-499-03 and CS-499-05 as well. While this single artifact does not completely cover all three outcomes, it does cover sections of 499-03 and 05. To be more specific, this artifact does well to demonstrate managing trade-offs in code, as well as show development while being mindful of security.

As I was working on this enhancement, there were a few notable things that came to light. The biggest takeaway for me was how complicated adjusting a project this far along can be. Modifying a project that’s already mostly complete can mean fundamental design choices are called into question. Other than this, I found that my lack of comments and documentation made it much more complicated of a task. Even though I was the one who wrote the code, looking back at it with no comments was like seeing it for the first time. The biggest challenge from this project was being unable to use JSON to serialize the chain after it was built. Knowing that using Pickle was a security risk, as it can be used to execute arbitrary code, I had to either find a way to minimize the risk to Pickle or find a way to reformat the data to be serializable. The Markov Chain state is represented by a two-word tuple however, and JSON requires this key to be a string to be serialized. As a result, I was forced to go with Pickle and so needed a way to increase the security of it. The option I came up with was to use a restricted form of loading data, which only accepts loading the immutable dictionary module as a precaution. This leads to any attempts to use outside modules like ‘os’ to run code get blocked and the load errors out. 
